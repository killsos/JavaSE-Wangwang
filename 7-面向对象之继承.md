## 面向对象之继承

#### 7.1 编程语言
	* 面向过程语言
	
	c语言: 
	
	程序由main 过程开始执行
	
	main 过程又可以调用别的过程
	
	当然很多个过程也可以集中在一个点h 的头文件中
	
	我们需要的时候导入头文件，类似于 java 中的导入包
	
	* 面向对象的编程语言
	
	C++ Java C#:
	 
	在面向对象的语言中万 事万物皆对象(类)
	 
	但不是有了类就可以称为面向对象的编程语言了
	
	它还必须满足面向对象的三个基本特征 即:封装，继承，多态
	
	JavaScript 虽然其内部也有类与对象的概念
	 
	但并没有完全满足面向对象的三个特征，所以我们把它叫基于对象的语言
	 
	判断一门语言是或否为面向 对象的标准:即是否支持封装，继承与多态
	

7.1.1 封装 继承  多态

	所谓封装 
	
	是指把客观事物封装成抽象的类
	
	并且类可以把自己的数据和方法只让可信的类或者对象操作
	
	对不可信的进行信息隐藏
	
	
	所谓继承 
	
	是指可以让某个类型的对象获得另一个类型的对象的属性的方法
	
	继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展
	
	可以通过“继承”（Inheritance）和“组合”（Composition）来实现
	
	继承概念的实现方式有二类：实现继承与接口继承
	
	实现继承是指直接使用基类的属性和方法而无需额外编码的能力
	
	接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力
	
	
	所谓多态
	
	就是指一个类实例的相同方法在不同情形有不同表现形式
	
	多态机制使具有不同内部结构的对象可以共享相同的外部接口
	
	这意味着，虽然针对不同对象的具体操作不同
	
	但通过一个公共的类 它们（那些操作）可以通过相同的方式予以调用
	
#### 7.2 继承的定义与实现

7.2.1 继承定义
	
	在一个类基础上 定义一个新类叫继承，原有的类叫父类，新生成的类叫子类
	
	面向对象编程叫OOP,还有一门知识叫 OOAD 面向对象的分析与设计
	
	在 OOAD中，继承又叫派生，父类又叫超类
	
	一个类继承自多个类，这是: 多继承  比如 C++就是这样的
	
	但Java中只有单继承
	
	* C++为最不纯粹面向对象语言的原因:
	
	一个原因就是因为 C++万恶的多继承
	
	还有一个重要原因是因为 C++中保留了指针
	
	指针的保留提高了 C++运行速度效率，但也增加了程序的复杂性，学习难度
	
	继承关系是通过“子类是父类”来确认的
	
7.2.1 继承实现

	在 Java 中，继承由 extends 关键字实现
	
#### 7.3 继承特点

	子类拥有父类的属性和方法
	
	子类可以有自己新的属性和方法
	
	子类可以重写(覆盖)父类的方法
	
	可以声明父类，创建子类
	
		声明的什么类型，就只能调用本类型的属性和方法
		
		创建的什么类型，运行什么类型的方法
		
		创建的什么类型，就可以强转为什么类型
		
7.3.1 特点一:
	
	子类拥有父类属性和方法
	
	private修饰的属性和方法 不能被继承
	
	继承的一个优点:减少代码冗余，实现代码复用
	
7.3.2 特点二:
	
	子类可以有自己新的属性和方法	
	
7.3.3 特点三:
	
	子类可以覆盖父类的方法(方法重写，方法覆盖)
	
	方法覆盖(方法重写):
	
	子类方法与父类方法具有相同的方法声明(方法头) 不同的 实现(方法体)
	
	方法覆盖是相对于父子类而言的，一个类无法实现覆盖
	
7.3.3 关键字:
	
	@Override
	
	@Override 用在子类方法声明的前面，表示此方法是重写的父类方法，当方法声明不满足时
	
	在 Java 源文件编译为类文件时就会报错
	
	也就是说我们在编译阶段就能发现这样的错误
	
7.3.5 特点四:
	
	可以声明父类，创建子类(父类能出现的地方，子类一定能出现)
	
		* 声明的什么类型，就只能调用本类型的属性和方法

		Father father;//生命父类
		father = new Son();//创建子类 
		father.hejiu();//这行代码出错，调用子类喝酒方法报错
		
		* 创建的什么类型，运行什么类型的方法
		
		* 创建的什么类型，就可以强转为什么类型
		
#### 7.4 THIS 与 SUPER 关键字

7.4.1 this 表示调用自己声明的属性和方法，super 表示调用父类声明的属性和方法
	
	public class Son extends Father { 
		@Override
		public void driver() { 
			System.out.println("儿子重写父类方法，开个BMW");
		}
		//子类新方法忆苦思甜
		public void ykst() { 
			//super表示调用父类声明的driver方法 
			super.driver(); 
			
			//this表示调用自己声明的driver方法 
			this.driver();
		} 
	}
	
	如果没有使用 this 和 super 关键字，则系统默认会全部调用子类方法
	
#### 7.5 继承中的构造方法

	创建对象一定会调用构造方法
	
	创建子类对象一定会调用父类的构造方法
	
	子类默认调用父类无参构造方法
	
	子类只能调用父类存在的构造方法
	
	子类构造方法中使用super调用父类构造方法，并且super必须放在第一行 
	
	构造方法中this表示调用本类其他构造方法，并且this必须放在第一行

	SUN建议: 给每个类添加一个无参的显式构造方 法，这样可以避免很多错误
	
	
#### 7.6 老祖宗 OBJECT 类
	
	我们知道 JAVA 是面向对象的语言，JAVA 中有一个特殊的类，它的名字就叫 Object(对象)
	
	并且 Object 类在 java.lang 包中，也就是说 Object 类可以直接使用而不需要导入
	
	JAVA 规定，如果某个类没有父类，那它就默认的继承自 Object 类
	
	也就是说，Object 是 java 体系所有类的直接或间接父类
	
	根据子类可以拥有父类的属性和方法，所以所有 java 类拥有可以从 Object 继承的属性和方法
	
	这样，当 SUN 要给 java 添加新功能时，只 要修改 Object 类就可以了，这也体现了继承的一个优点
	
	
###### Object类中一些重要的方法

7.6.1  public String toString()
	
	这个方法我们前期使用过，那大家现在知道是重写的 Object 的方法
	
	它还特殊的地方是当打印对象时只写对象名不写方法名，默认调用此方法
	
	如果不重写 toString() 返回值是: 包名.类名@内存地址
	
	System.out.println(student);  // 打印对象时只写对象名不写方法名，默认调用此方法
	
	
7.6.2  protected void finalize() throws Throwable:

	类似 C++的析构方法，在对象消亡时由系统自动调用
	
7.6.3  public boolean equals(Object obj):
	
	比较两个对象的数值(堆空间中存储的对象数值)是否一致
	
	一般也由子类覆盖，比如我们使用的 String的 equals 方法就是覆盖的它
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	







